// Generated by CoffeeScript 2.7.0
var is_promise, normalize, normalize_options;

import {
  is_object_literal,
  merge,
  mutate
} from 'mixme';

is_promise = function(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
};

normalize_options = function(options, argument, position) {
  if (is_object_literal(argument)) {
    return mutate(options, argument);
  } else if (typeof argument === 'function') {
    return options.handler = argument;
  } else if (typeof argument === 'boolean') {
    return mutate(options, {
      concurrency: typeof argument ? -1 : 1
    });
  } else if (typeof argument === 'number') {
    return options.concurrency = argument;
  } else {
    if (!is_object_literal(argument)) {
      throw Error(`Invalid argument: ${position} argument \`option\` must be one of object, boolean or number, got ${JSON.stringify(argument)}`);
    }
  }
};

normalize = function() {
  var elements, options;
  // elements, [options]
  // items, function, [options]
  // items, options, function
  elements = void 0;
  options = {
    concurrency: 1,
    pause: false,
    relax: false
  };
  if (arguments.length === 0) {
    elements = [];
  } else if (arguments.length === 1) {
    if (Array.isArray(arguments[0])) {
      elements = arguments[0];
    } else {
      normalize_options(options, arguments[0], 'first');
    }
  } else if (arguments.length === 2) {
    elements = arguments[0];
    normalize_options(options, arguments[1], 'second');
  } else if (arguments.length === 3) {
    elements = arguments[0];
    normalize_options(options, arguments[1], 'second');
    normalize_options(options, arguments[2], 'third');
  } else {
    // # items, options, handler
    // if is_object_literal(arguments[1]) or ['boolean', 'number'].includes(typeof arguments[1])
    //   if is_object_literal(arguments[1])
    //     mutate options, arguments[1]
    //   else if typeof arguments[1] is 'boolean'
    //     mutate options, concurrency: if typeof arguments[1] then -1 else 1
    //   else
    //     options.concurrency = arguments[1]
    //   throw Error "Invalid argument: third argument `handler` must be a function, got #{JSON.stringify arguments[2]}" unless typeof arguments[2] is 'function'
    //   options.handler = arguments[2]
    // # items, handler, options
    // if is_object_literal(arguments[2]) or ['boolean', 'number'].includes(typeof arguments[2])
    //   throw Error "Invalid argument: third argument `handler` must be a function, got #{JSON.stringify arguments[1]}" unless typeof arguments[1] is 'function'
    //   options.handler = arguments[1]
    //   if is_object_literal(arguments[2])
    //     mutate options, arguments[2]
    //   else if typeof arguments[2] is 'boolean'
    //     mutate options, concurrency: if typeof arguments[2] then -1 else 1
    //   else
    //     options.concurrency = arguments[2]
    throw Error("Invalid argument");
  }
  return {
    elements: elements,
    options: options
  };
};

export default function(...args) {
  var all, elements, internal, options, scheduler, stack, state;
  ({elements, options} = normalize.apply(null, arguments));
  stack = [];
  state = {
    error: false,
    paused: options.pause,
    running: 0,
    count: -1
  };
  internal = {
    pump: function() {
      var item;
      if (!stack.length) {
        return;
      }
      if (state.error && !options.relax) {
        while (item = stack.shift()) {
          item.reject.call(null, state.error);
        }
      }
      if (state.paused) {
        return;
      }
      if (options.concurrency > 0 && state.running === options.concurrency) {
        return;
      }
      state.running++;
      item = stack.shift();
      return setImmediate(async function() {
        var error, result;
        try {
          state.count++;
          result = options.handler ? (await options.handler.call(null, item.handler, state.count)) : typeof item.handler === 'function' ? (await item.handler.call()) : (await item.handler);
          state.running--;
          item.resolve.call(null, result);
          return internal.pump();
        } catch (error1) {
          error = error1;
          state.running--;
          state.error = error;
          item.reject.call(null, error);
          return internal.pump();
        }
      });
    }
  };
  all = function(elements, options) {
    return new Promise(function(resolve, reject) {
      var element, isArray;
      isArray = Array.isArray(elements);
      if (isArray) {
        return Promise.all((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = elements.length; i < len; i++) {
            element = elements[i];
            results.push(all(element, options));
          }
          return results;
        })()).then(resolve, reject);
      } else {
        stack.push({
          handler: elements,
          resolve: resolve,
          reject: reject,
          options: options
        });
        return internal.pump();
      }
    });
  };
  scheduler = all(elements);
  scheduler.get = function() {
    if (arguments.length === 0) {
      return merge(options);
    }
    if (arguments.length === 1) {
      return options[arguments[0]];
    } else {
      throw Error(`Invalid argument: \`get\` expect one or two arguments, got ${arguments.length}`);
    }
  };
  scheduler.pause = function() {
    state.paused = true;
    return scheduler;
  };
  scheduler.push = function(elements) {
    return all(elements);
  };
  scheduler.resume = function() {
    state.paused = false;
    internal.pump();
    return scheduler;
  };
  return scheduler;
};
