// Generated by CoffeeScript 1.4.0
var Each, events, glob, path, stream, util;

events = require('events');

stream = require('stream');

path = require('path');

glob = require('glob');

util = require('util');

/*
each(elements)
.parallel(false|true|integer)
.sync(false)
.times(1)
.repeat(1)
.files(cwd, ['./*.coffee'])
.write(element)
.pause()
.resume()
.on('item', callback)
.on('error', callback)
.on('end', callback)
.on('both', callback)
Chained and parallel async iterator in one elegant function
*/


Each = function(options, _elements) {
  var isObject, self, type,
    _this = this;
  this.options = options;
  this._elements = _elements;
  if (arguments.length === 1) {
    this._elements = this.options;
    this.options = {};
  }
  type = typeof this._elements;
  if (this._elements === null || type === 'undefined') {
    this._elements = [];
  } else if (type === 'number' || type === 'string' || type === 'function' || type === 'boolean') {
    this._elements = [this._elements];
  } else if (!Array.isArray(this._elements)) {
    isObject = true;
  }
  if (isObject) {
    this._keys = Object.keys(this._elements);
  }
  this._errors = [];
  this._parallel = 1;
  this._sync = false;
  this._times = 1;
  this._repeat = false;
  this._endable = 1;
  this._close = false;
  events.EventEmitter.call(this, this.options);
  this.total = this._keys ? this._keys.length : this._elements.length;
  this.setMaxListeners(100);
  this.started = 0;
  this.done = 0;
  this.paused = 0;
  this.readable = true;
  self = this;
  process.nextTick(function() {
    return _this._run();
  });
  return this;
};

util.inherits(Each, events.EventEmitter);

Each.prototype._run = function() {
  var args, emit, err, error, index, l, self, _i, _len, _ref;
  if (this.paused) {
    return;
  }
  error = null;
  if (this._endable === 1 && (this._close || this.done === this.total * this._times || (this._errors.length && this.started === this.done))) {
    this.readable = false;
    if (this._errors.length) {
      if (this._parallel !== 1) {
        if (this._errors.length === 1) {
          error = this._errors[0];
          error.errors = [];
        } else {
          error = new Error("Multiple errors (" + this._errors.length + ")");
          error.errors = this._errors;
        }
      } else {
        error = this._errors[0];
        error.errors = [];
      }
      if (this.listeners('error').length || !this.listeners('both').length) {
        this.emit('error', error);
      }
    } else {
      args = [];
      this.emit('end');
    }
    this.emit('both', error, this.done);
    return;
  }
  if (this._errors.length !== 0) {
    return;
  }
  while ((this._parallel === true ? (this.total * this._times - this.started) > 0 : Math.min(this._parallel - this.started + this.done, this.total * this._times - this.started))) {
    if (this._errors.length !== 0) {
      break;
    }
    if (this._close) {
      break;
    }
    if (this._repeat) {
      index = this.started % this._elements.length;
    } else {
      index = Math.floor(this.started / this._times);
    }
    this.started++;
    try {
      self = this;
      _ref = this.listeners('item');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        emit = _ref[_i];
        l = emit.length;
        if (this._sync) {
          l++;
        }
        switch (l) {
          case 1:
            args = [];
            break;
          case 2:
            if (this._keys) {
              args = [this._elements[this._keys[index]]];
            } else {
              args = [this._elements[index]];
            }
            break;
          case 3:
            if (this._keys) {
              args = [this._keys[index], this._elements[this._keys[index]]];
            } else {
              args = [this._elements[index], index];
            }
            break;
          case 4:
            if (this._keys) {
              args = [this._keys[index], this._elements[this._keys[index]], index];
            } else {
              return self._next(new Error('Invalid arguments in item callback'));
            }
            break;
          default:
            return self._next(new Error('Invalid arguments in item callback'));
        }
        if (!this._sync) {
          args.push((function() {
            var count;
            count = 0;
            return function(err) {
              if (err) {
                return self._next(err);
              }
              if (++count !== 1) {
                err = new Error('Multiple call detected');
                if (self.readable) {
                  return self._next(err);
                } else {
                  throw err;
                }
              }
              return self._next();
            };
          })());
        }
        err = emit.apply(null, args);
        if (this._sync) {
          self._next(err);
        }
      }
    } catch (err) {
      if (self.readable) {
        self._next(err);
      } else {
        throw err;
      }
    }
  }
  return null;
};

Each.prototype._next = function(err) {
  if ((err != null) && err instanceof Error) {
    this._errors.push(err);
  }
  this.done++;
  return this._run();
};

Each.prototype.end = function() {
  console.log('Function `end` deprecated, use `close` instead.');
  return this.close();
};

Each.prototype.close = function() {
  this._close = true;
  this._next();
  return this;
};

Each.prototype.sync = function(s) {
  this._sync = s;
  return this;
};

Each.prototype.repeat = function(t) {
  this._repeat = true;
  this._times = t;
  if (this._elements.length === 0) {
    this.write(null);
  }
  return this;
};

Each.prototype.times = function(t) {
  this._times = t;
  if (this._elements.length === 0) {
    this.write(null);
  }
  return this;
};

Each.prototype.files = function(base, pattern) {
  var p, _i, _len,
    _this = this;
  if (arguments.length === 1) {
    pattern = base;
    base = null;
  }
  if (Array.isArray(pattern)) {
    for (_i = 0, _len = pattern.length; _i < _len; _i++) {
      p = pattern[_i];
      this.files(p);
    }
    return this;
  }
  this._endable--;
  if (base) {
    pattern = path.resolve(base, pattern);
  }
  glob(pattern, function(err, files) {
    var file, _j, _len1;
    for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
      file = files[_j];
      _this._elements.push(file);
    }
    _this.total += files.length;
    return process.nextTick(function() {
      _this._endable++;
      return _this._run();
    });
  });
  return this;
};

Each.prototype.write = Each.prototype.push = function(item) {
  var l;
  l = arguments.length;
  if (l === 1) {
    this._elements.push(arguments[0]);
  } else if (l === 2) {
    if (!this._keys) {
      this._keys = [];
    }
    this._keys.push(arguments[0]);
    this._elements[arguments[0]] = arguments[1];
  }
  this.total++;
  return this;
};

Each.prototype.unshift = function(item) {
  var index, l;
  l = arguments.length;
  if (this._repeat) {
    index = this.started % this._elements.length;
  } else {
    index = Math.floor(this.started / this._times);
  }
  if (l === 1) {
    this._elements.splice(index, 0, arguments[0]);
  } else if (l === 2) {
    if (!this._keys) {
      this._keys = [];
    }
    this._keys.splice(index, 0, arguments[0]);
    this._elements[arguments[0]] = arguments[1];
  }
  this.total++;
  return this;
};

Each.prototype.pause = function() {
  return this.paused++;
};

Each.prototype.resume = function() {
  this.paused--;
  return this._run();
};

Each.prototype.parallel = function(mode) {
  if (typeof mode === 'number') {
    this._parallel = mode;
  } else if (mode) {
    this._parallel = mode;
  } else {
    this._parallel = 1;
  }
  return this;
};

module.exports = function(elements) {
  return new Each(elements);
};

module.exports.Each = Each;
