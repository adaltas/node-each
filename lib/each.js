// Generated by CoffeeScript 1.4.0
var glob, path;

path = require('path');

glob = require('glob');

/*
each(elements)
.parallel(false|true|integer)
.sync(false)
.times(1)
.repeat(1)
.files(cwd, ['./*.coffee'])
.write(element)
.pause()
.resume()
.on('item', callback)
.on('error', callback)
.on('end', callback)
.on('both', callback)
Chained and parallel async iterator in one elegant function
*/


module.exports = function(elements) {
  var arglength, eacher, end, endable, errors, events, isObject, keys, next, parallel, repeat, run, sync, times, type;
  type = typeof elements;
  if (elements === null || type === 'undefined') {
    elements = [];
  } else if (type === 'number' || type === 'string' || type === 'function' || type === 'boolean') {
    elements = [elements];
  } else if (!Array.isArray(elements)) {
    isObject = true;
  }
  arglength = arguments.length;
  if (isObject) {
    keys = Object.keys(elements);
  }
  errors = [];
  parallel = 1;
  events = {
    item: [],
    error: [],
    end: [],
    both: []
  };
  times = [];
  eacher = {};
  eacher.total = keys ? keys.length : elements.length;
  eacher.started = 0;
  eacher.done = 0;
  sync = false;
  times = 1;
  repeat = false;
  endable = 1;
  eacher.paused = 0;
  eacher.readable = true;
  end = false;
  eacher.write = eacher.push = function(item) {
    var l;
    l = arguments.length;
    if (l === 1) {
      elements.push(arguments[0]);
    } else if (l === 2) {
      if (!keys) {
        keys = [];
      }
      keys.push(arguments[0]);
      elements[arguments[0]] = arguments[1];
    }
    eacher.total++;
    return eacher;
  };
  eacher.unshift = function(item) {
    var index, l;
    l = arguments.length;
    if (repeat) {
      index = eacher.started % elements.length;
    } else {
      index = Math.floor(eacher.started / times);
    }
    if (l === 1) {
      elements.splice(index, 0, arguments[0]);
    } else if (l === 2) {
      if (!keys) {
        keys = [];
      }
      keys.splice(index, 0, arguments[0]);
      elements[arguments[0]] = arguments[1];
    }
    eacher.total++;
    return eacher;
  };
  eacher.pause = function() {
    return eacher.paused++;
  };
  eacher.resume = function() {
    eacher.paused--;
    return run();
  };
  eacher.parallel = function(mode) {
    if (typeof mode === 'number') {
      parallel = mode;
    } else if (mode) {
      parallel = mode;
    } else {
      parallel = 1;
    }
    return eacher;
  };
  eacher.on = function(ev, callback) {
    events[ev].push(callback);
    return eacher;
  };
  eacher.end = function() {
    end = true;
    next();
    return eacher;
  };
  eacher.sync = function(s) {
    sync = s;
    return eacher;
  };
  eacher.repeat = function(t) {
    repeat = true;
    times = t;
    if (elements.length === 0) {
      eacher.write(null);
    }
    return eacher;
  };
  eacher.times = function(t) {
    times = t;
    if (elements.length === 0) {
      eacher.write(null);
    }
    return eacher;
  };
  eacher.files = function(base, pattern) {
    var p, _i, _len;
    if (arguments.length === 1) {
      pattern = base;
      base = null;
    }
    if (Array.isArray(pattern)) {
      for (_i = 0, _len = pattern.length; _i < _len; _i++) {
        p = pattern[_i];
        this.files(p);
      }
      return this;
    }
    endable--;
    if (base) {
      pattern = path.resolve(base, pattern);
    }
    glob(pattern, function(err, files) {
      var file, _j, _len1;
      eacher.total += files.length;
      for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
        file = files[_j];
        elements.push(file);
      }
      return process.nextTick(function() {
        endable++;
        return run();
      });
    });
    return eacher;
  };
  run = function() {
    var args, emit, err, error, index, l, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    if (eacher.paused) {
      return;
    }
    error = null;
    if (endable === 1 && (end || eacher.done === eacher.total * times || (errors.length && eacher.started === eacher.done))) {
      eacher.readable = false;
      if (errors.length) {
        if (parallel !== 1) {
          if (errors.length === 1) {
            error = errors[0];
            error.errors = [];
          } else {
            error = new Error("Multiple errors (" + errors.length + ")");
            error.errors = errors;
          }
        } else {
          error = errors[0];
          error.errors = [];
        }
        _ref = events.error;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          emit = _ref[_i];
          if (events.error.length) {
            emit(error);
          }
        }
      } else {
        args = [];
        _ref1 = events.end;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          emit = _ref1[_j];
          emit(eacher.done);
        }
      }
      _ref2 = events.both;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        emit = _ref2[_k];
        emit(error, eacher.done);
      }
      if (error && !events.error.length && !events.both.length) {
        throw error;
      }
      return;
    }
    if (errors.length !== 0) {
      return;
    }
    while ((parallel === true ? (eacher.total * times - eacher.started) > 0 : Math.min(parallel - eacher.started + eacher.done, eacher.total * times - eacher.started))) {
      if (errors.length !== 0) {
        break;
      }
      if (end) {
        break;
      }
      if (repeat) {
        index = eacher.started % elements.length;
      } else {
        index = Math.floor(eacher.started / times);
      }
      eacher.started++;
      try {
        _ref3 = events.item;
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          emit = _ref3[_l];
          l = emit.length;
          if (sync) {
            l++;
          }
          switch (l) {
            case 1:
              args = [];
              break;
            case 2:
              if (keys) {
                args = [elements[keys[index]]];
              } else {
                args = [elements[index]];
              }
              break;
            case 3:
              if (keys) {
                args = [keys[index], elements[keys[index]]];
              } else {
                args = [elements[index], index];
              }
              break;
            case 4:
              if (keys) {
                args = [keys[index], elements[keys[index]], index];
              } else {
                return next(new Error('Invalid arguments in item callback'));
              }
              break;
            default:
              return next(new Error('Invalid arguments in item callback'));
          }
          if (!sync) {
            args.push((function() {
              var count;
              count = 0;
              return function(err) {
                if (err) {
                  return next(err);
                }
                if (++count !== 1) {
                  err = new Error('Multiple call detected');
                  if (eacher.readable) {
                    return next(err);
                  } else {
                    throw err;
                  }
                }
                return next();
              };
            })());
          }
          err = emit.apply(null, args);
          if (sync) {
            next(err);
          }
        }
      } catch (err) {
        if (eacher.readable) {
          next(err);
        } else {
          throw err;
        }
      }
    }
    return null;
  };
  next = function(err) {
    if ((err != null) && err instanceof Error) {
      errors.push(err);
    }
    eacher.done++;
    return run();
  };
  process.nextTick(run);
  return eacher;
};
